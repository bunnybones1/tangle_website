{
  "version": 3,
  "sources": ["../../tangle/tangle_ts/src/room.ts", "../../tangle/tangle_ts/src/message_encoding.ts", "../../tangle/tangle_ts/src/rust_utilities.ts", "../../tangle/tangle_ts/src/time_machine.ts", "../../tangle/tangle_ts/src/tangle.ts", "../index.ts"],
  "sourcesContent": ["import { RustUtilities } from \"./rust_utilities\";\n\nexport interface RoomConfiguration {\n    server_url?: string,\n    room_name?: string,\n    ice_servers?: RTCIceServer[],\n    on_state_change?: (room_state: RoomState) => void;\n    on_peer_joined?: (peer_id: PeerId) => void;\n    on_peer_left?: (peer_id: PeerId, time: number) => void;\n    on_message?: (peer_id: PeerId, message: Uint8Array) => void;\n}\n\nexport type PeerId = number;\n\nexport enum RoomState {\n    Joining,\n    Connected,\n    Disconnected\n}\n\ntype Peer = {\n    id: PeerId,\n    connection: RTCPeerConnection,\n    data_channel: RTCDataChannel,\n    ready: boolean,\n    latest_message_data: Uint8Array\n    latest_message_offset: number,\n}\n\nenum MessageType {\n    MultiPartStart = 1,\n    MultiPartContinuation = 2,\n    SinglePart = 3,\n    SinglePartGzipped = 4,\n}\n\nconst MAX_MESSAGE_SIZE = 16_000;\n\n// TODO: This is generated by ChatGPT. Audit it.\nfunction compute_id_from_ip(ipAddress: string): number {\n    let uniqueNumber = 0;\n    const parts = ipAddress.split(':');\n    const ip = parts[0].split('.');\n    const port = parseInt(parts[1], 10);\n\n    for (let i = 0; i < 4; i++) {\n        uniqueNumber += parseInt(ip[i], 10) * Math.pow(256, 3 - i);\n    }\n    uniqueNumber += port;\n\n    return uniqueNumber;\n}\n\nexport class Room {\n    private _peers_to_join: Set<PeerId> = new Set();\n    private _current_state: RoomState = RoomState.Disconnected;\n    private _peers: Map<PeerId, Peer> = new Map();\n    private _configuration: RoomConfiguration = {};\n    private _outgoing_data_chunk = new Uint8Array(MAX_MESSAGE_SIZE + 5);\n    private _rust_utilities: RustUtilities;\n    private _server_socket?: WebSocket;\n\n    my_id = 0;\n\n    // Used for testing\n    private _artificial_delay = 0;\n\n    constructor(rust_utilities: RustUtilities) {\n        this._rust_utilities = rust_utilities;\n    }\n\n    static async setup(_configuration: RoomConfiguration, rust_utilities: RustUtilities): Promise<Room> {\n        const room = new Room(rust_utilities);\n        await room._setup_inner(_configuration);\n        return room;\n    }\n\n    private message_peer_inner(peer: Peer, data: Uint8Array) {\n        if (!(peer.data_channel.readyState === \"open\")) {\n            // TODO: This could result in desyncs if this happens.\n            return;\n        }\n\n        // Gzip encode large messages.\n        // For very small messages Gzip encoding actually makes them bigger.\n        // This conditional is separate so that if the Gzip data is < MAX_MESSAGE_SIZE \n        // it becomes a small message.\n        let message_type = MessageType.SinglePart;\n        if (data.byteLength > MAX_MESSAGE_SIZE) {\n            message_type = MessageType.SinglePartGzipped;\n            data = this._rust_utilities.gzip_encode(data);\n        }\n\n        // If the message is too large fragment it. \n        // TODO: If there's not space in the outgoing channel push messages to an outgoing buffer.\n        if (data.byteLength > MAX_MESSAGE_SIZE) {\n            this._outgoing_data_chunk[0] = MessageType.MultiPartStart;\n            new DataView(this._outgoing_data_chunk.buffer).setUint32(1, data.byteLength);\n\n            this._outgoing_data_chunk.set(data.subarray(0, MAX_MESSAGE_SIZE), 5);\n            peer.data_channel.send(this._outgoing_data_chunk);\n\n            let data_offset = data.subarray(MAX_MESSAGE_SIZE);\n\n            while (data_offset.byteLength > 0) {\n                const length = Math.min(data_offset.byteLength, MAX_MESSAGE_SIZE);\n                this._outgoing_data_chunk[0] = MessageType.MultiPartContinuation;\n                this._outgoing_data_chunk.set(data_offset.subarray(0, length), 1);\n                data_offset = data_offset.subarray(length);\n\n                peer.data_channel.send(this._outgoing_data_chunk.subarray(0, length + 1));\n\n            }\n        } else {\n            this._outgoing_data_chunk[0] = message_type;\n            this._outgoing_data_chunk.set(data, 1);\n\n            peer.data_channel.send(this._outgoing_data_chunk.subarray(0, data.byteLength + 1));\n        }\n\n    }\n\n    send_message(data: Uint8Array, peer_id?: PeerId) {\n        if (peer_id) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const peer = this._peers.get(peer_id)!;\n            this.message_peer_inner(peer, data);\n        } else {\n            for (const peer of this._peers.values()) {\n                if (!peer.ready) {\n                    continue;\n                }\n\n                this.message_peer_inner(peer, data);\n            }\n        }\n    }\n\n    get_lowest_latency_peer(): PeerId | undefined {\n        // TODO: Implement this.\n        return this._peers.entries().next().value?.[0];\n    }\n\n    private async _setup_inner(room_configuration: RoomConfiguration) {\n        this._configuration = room_configuration;\n        this._configuration.server_url ??= \"tangle-server.fly.dev\";\n        this._configuration.room_name ??= \"\";\n\n        // TODO: Do not use metered's Turn servers\n        // Investigate routing traffic through Tangle's matchmaking server or other Tangle servers.\n        this._configuration.ice_servers ??= [\n            {\n                urls: \"stun:relay.metered.ca:80\",\n            },\n            {\n                urls: \"stun:stun1.l.google.com:19302\"\n            },\n            {\n                urls: \"turn:relay.metered.ca:80\",\n                username: \"acb3fd59dc274dbfd4e9ef21\",\n                credential: \"1zeDaNt7C85INfxl\",\n            },\n            {\n                urls: \"turn:relay.metered.ca:443\",\n                username: \"acb3fd59dc274dbfd4e9ef21\",\n                credential: \"1zeDaNt7C85INfxl\",\n            },\n            {\n                urls: \"turn:relay.metered.ca:443?transport=tcp\",\n                username: \"acb3fd59dc274dbfd4e9ef21\",\n                credential: \"1zeDaNt7C85INfxl\",\n            },\n        ];\n\n        const connect_to_server = () => {\n            const server_socket = new WebSocket(\"wss://\" + this._configuration.server_url);\n\n            let keep_alive_interval: number;\n\n            server_socket.onopen = () => {\n                console.log(\"[room] Connection established with server\");\n                console.log(\"[room] Requesting to join room: \", this._configuration.room_name);\n                server_socket.send(JSON.stringify({ 'join_room': this._configuration.room_name }));\n\n                // Poke the server every 10 seconds to ensure it doesn't drop our connection.\n                // Without this it seems browsers don't send WebSocket native 'pings' as expected.\n                // and some server providers (like fly.io) will shutdown inactive TCP sockets.\n                // This also gives the server a chance to disconnect peers that become unresponsive.\n                clearInterval(keep_alive_interval);\n                keep_alive_interval = setInterval(function () {\n                    server_socket.send(\"keep_alive\");\n                }, 10_000);\n            };\n\n            server_socket.onclose = (event) => {\n                if (this._current_state != RoomState.Disconnected) {\n                    clearInterval(keep_alive_interval);\n\n                    // Disconnecting from the WebSocket is considered a full disconnect from the room.\n\n                    // Call the on_peer_left handler for each peer\n                    for (const peer_id of this._peers.keys()) {\n                        this._configuration.on_peer_left?.(peer_id, Date.now());\n                    }\n\n                    this._current_state = RoomState.Disconnected;\n                    this._peers_to_join.clear();\n                    this._peers.clear();\n\n                    if (event.wasClean) {\n                        console.log(`[room] Server connection closed cleanly, code=${event.code} reason=${event.reason}`);\n                    } else {\n                        console.log(`[room] Server connection unexpectedly closed. code=${event.code} reason=${event.reason}`);\n                        console.log(\"event: \", event);\n                    }\n\n                    this._configuration.on_state_change?.(this._current_state);\n                }\n\n                // Attempt to reconnect\n                setTimeout(function () {\n                    console.log(\"[room] Attempting to reconnect to server...\")\n                    connect_to_server();\n                }, 250);\n            };\n\n            server_socket.onerror = function (error) {\n                console.log(`[room] Server socket error:`, error);\n                server_socket.close();\n            };\n\n            server_socket.onmessage = async (event) => {\n                const last_index = event.data.lastIndexOf('}');\n                const json = event.data.substring(0, last_index + 1);\n\n                const message = JSON.parse(json);\n                // peer_id is appended by the server to the end of incoming messages.\n                const peer_ip = event.data.substring(last_index + 1).trim();\n                const peer_id = compute_id_from_ip(peer_ip);\n\n                if (message.room_name) {\n                    /*\n                    const url = new URL(message.room_name);\n                    const location = document.location;\n                    if (url.href != location.href) {\n                        console.error(\"[room] Tried to join a room that doesn't match current host URL\");\n                        return;\n                    }\n                    */\n\n                    // Received when joining a room for the first time.\n                    console.log(\"[room] Entering room: \", message.room_name);\n\n                    this._current_state = RoomState.Joining;\n\n                    const peers_to_join_ids = message.peers.map(compute_id_from_ip);\n                    this._peers_to_join = new Set(peers_to_join_ids);\n\n                    this._configuration.on_state_change?.(this._current_state);\n\n                    // If we've already connected to a peer then remove it from _peers_to_join.\n                    for (const key of this._peers.keys()) {\n                        this._peers_to_join.delete(key);\n                    }\n                    this.check_if_joined();\n\n                    this.my_id = compute_id_from_ip(message.your_ip);\n                    console.log(\"[room] My id is: %d\", this.my_id);\n                } else if (message.join_room) {\n                    console.log(\"[room] Peer joining room: \", peer_id);\n                    this.make_rtc_peer_connection(peer_ip, peer_id, server_socket);\n                } else if (message.offer) {\n                    const peer_connection = this.make_rtc_peer_connection(peer_ip, peer_id, server_socket);\n                    await peer_connection.setRemoteDescription(new RTCSessionDescription(message.offer));\n                    const answer = await peer_connection.createAnswer();\n                    await peer_connection.setLocalDescription(answer);\n                    server_socket.send(JSON.stringify({ 'answer': answer, 'destination': peer_ip }));\n                } else if (message.answer) {\n                    const remoteDesc = new RTCSessionDescription(message.answer);\n                    await this._peers.get(peer_id)?.connection.setRemoteDescription(remoteDesc);\n                } else if (message.new_ice_candidate) {\n                    try {\n                        await this._peers.get(peer_id)?.connection.addIceCandidate(message.new_ice_candidate);\n                    } catch (e) {\n                        console.error(\"[room] Error adding received ice candidate\", e);\n                    }\n                } else if (message.disconnected_peer_id) {\n                    const disconnected_peer_id = compute_id_from_ip(message.disconnected_peer_id);\n                    console.log(\"[room] Peer left: \", disconnected_peer_id);\n                    this.remove_peer(disconnected_peer_id, message.time);\n                    this._peers_to_join.delete(disconnected_peer_id);\n                    this.check_if_joined();\n                }\n            };\n        };\n        connect_to_server();\n    }\n\n    private check_if_joined() {\n        if (this._current_state == RoomState.Joining && this._peers_to_join.size == 0) {\n            this._current_state = RoomState.Connected;\n            this._configuration.on_state_change?.(this._current_state);\n        }\n    }\n\n    private make_rtc_peer_connection(peer_ip: string, peer_id: PeerId, server_socket: WebSocket): RTCPeerConnection {\n        const peer_connection = new RTCPeerConnection({ 'iceServers': this._configuration.ice_servers });\n\n        // TODO: If this is swapped to a more unreliable UDP-like protocol then ordered and maxRetransmits should be set to false and 0.\n        //\n        // maxRetransmits: null is meant to be the default but explicitly setting it seems to trigger a Chrome\n        // bug where some packets are dropped.\n        // TODO: Report this bug.\n        const data_channel = peer_connection.createDataChannel(\"sendChannel\", { negotiated: true, id: 2, ordered: true });\n        data_channel.binaryType = \"arraybuffer\";\n\n        peer_connection.onicecandidate = event => {\n            console.log(\"[room] New ice candidate: \", event.candidate);\n            if (event.candidate) {\n                console.log(JSON.stringify({ 'new_ice_candidate': event.candidate, 'destination': peer_ip }));\n                server_socket.send(JSON.stringify({ 'new_ice_candidate': event.candidate, 'destination': peer_ip }));\n            }\n        };\n\n        peer_connection.onicecandidateerror = (event) => {\n            console.log(\"[room] Ice candidate error: \", event);\n        };\n\n        peer_connection.onnegotiationneeded = async () => {\n            console.log(\"[room] Negotiation needed\");\n            const offer = await peer_connection.createOffer();\n            await peer_connection.setLocalDescription(offer);\n            server_socket.send(JSON.stringify({ 'offer': offer, 'destination': peer_ip }));\n        };\n\n        peer_connection.onsignalingstatechange = () => {\n            console.log(\"[room] Signaling state changed: \", peer_connection.signalingState)\n        };\n\n        peer_connection.onconnectionstatechange = () => {\n            console.log(\"[room] Connection state changed: \", peer_connection.connectionState)\n        };\n\n        peer_connection.ondatachannel = (event) => {\n            peer.data_channel = event.channel;\n        };\n\n        data_channel.onopen = () => {\n            this._peers_to_join.delete(peer_id);\n            peer.ready = true;\n            this._configuration.on_peer_joined?.(peer_id);\n            this.check_if_joined();\n        }\n\n        data_channel.onmessage = (event) => {\n            // First check that this peer hasn't been officially disconnected.\n            if (this._peers.get(peer_id)) {\n                if (event.data.byteLength > 0) {\n                    // Defragment the message\n                    const message_data = new Uint8Array(event.data);\n                    switch (message_data[0]) {\n                        case MessageType.SinglePart: {\n                            // Call the user provided callback\n                            // Message received\n                            const data = message_data.subarray(1);\n\n                            // TODO: This introduces a potential one-frame delay on incoming events.\n                            setTimeout(() => {\n                                this._configuration.on_message?.(peer_id, data);\n                            }, this._artificial_delay);\n                            break;\n                        }\n                        case MessageType.SinglePartGzipped: {\n                            // Call the user provided callback\n                            const data = this._rust_utilities.gzip_decode(message_data.subarray(1));\n                            // TODO: This introduces a potential one-frame delay on incoming events.\n                            setTimeout(() => {\n                                this._configuration.on_message?.(peer_id, data);\n                            }, this._artificial_delay);\n                            break;\n                        }\n                        case MessageType.MultiPartStart: {\n                            const data = new DataView(message_data.buffer, 1);\n                            const length = data.getUint32(0);\n\n                            peer.latest_message_data = new Uint8Array(length);\n                            this.multipart_data_received(peer, message_data.subarray(5));\n                            break;\n                        }\n                        case MessageType.MultiPartContinuation: {\n                            this.multipart_data_received(peer, message_data.subarray(1));\n                        }\n                    }\n                }\n            } else {\n                console.error(\"DISCARDING MESSAGE FROM PEER: \", event.data);\n            }\n        }\n\n        const peer = { id: peer_id, connection: peer_connection, data_channel, ready: false, latest_message_data: new Uint8Array(0), latest_message_offset: 0 };\n        this._peers.set(peer_id, peer);\n        return peer_connection;\n    }\n\n    private multipart_data_received(peer: Peer, data: Uint8Array) {\n        peer.latest_message_data.set(data, peer.latest_message_offset);\n        peer.latest_message_offset += data.byteLength;\n\n        if (peer.latest_message_offset == peer.latest_message_data.length) {\n            let data = peer.latest_message_data;\n            data = this._rust_utilities.gzip_decode(data);\n\n            // TODO: This introduces a potential one-frame delay on incoming events.\n            // Message received\n            setTimeout(() => {\n                this._configuration.on_message?.(peer.id, data);\n            }, this._artificial_delay);\n            peer.latest_message_offset = 0;\n            peer.latest_message_data = new Uint8Array(0);\n        }\n    }\n\n    private remove_peer(peer_id: PeerId, time: number) {\n        const peer = this._peers.get(peer_id);\n\n        if (peer) {\n            peer.connection.close();\n            this._peers.delete(peer_id);\n            this._configuration.on_peer_left?.(peer_id, time);\n        }\n    }\n\n    disconnect() {\n        this._server_socket?.close();\n    }\n}\n\n", "import { WasmSnapshot, TimeStamp } from \"./time_machine\";\n\nenum NumberTag {\n    F64,\n    I64,\n}\n\nconst text_encoder = new TextEncoder();\nconst text_decoder = new TextDecoder();\n\nexport class MessageWriterReader {\n    output: Uint8Array;\n    data_view: DataView;\n    offset = 0;\n\n    constructor(output: Uint8Array) {\n        this.output = output;\n        this.data_view = new DataView(output.buffer, output.byteOffset);\n    }\n\n    get_result_array() {\n        return this.output.subarray(0, this.offset);\n    }\n\n    write_raw_bytes(bytes: Uint8Array) {\n        this.output.subarray(this.offset).set(bytes);\n        this.offset += bytes.length;\n    }\n\n    read_remaining_raw_bytes() {\n        return this.output.subarray(this.offset);\n    }\n\n    read_fixed_raw_bytes(length: number) {\n        const result = this.output.slice(this.offset, this.offset + length);\n        this.offset += length;\n        return result;\n    }\n\n    write_string(string: string) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const length = text_encoder.encodeInto(string, this.output.subarray(this.offset + 4)).written!;\n        this.data_view.setUint32(this.offset, length);\n        this.offset += length + 4;\n    }\n\n    read_string(): string {\n        const length = this.read_u32();\n        const result = text_decoder.decode(this.output.subarray(this.offset, this.offset + length));\n        this.offset += length;\n        return result;\n    }\n\n    write_u8(v: number) {\n        this.data_view.setUint8(this.offset, v);\n        this.offset += 1;\n    }\n\n    write_u16(v: number) {\n        this.data_view.setUint16(this.offset, v);\n        this.offset += 2;\n    }\n\n    write_u32(v: number) {\n        this.data_view.setUint32(this.offset, v);\n        this.offset += 4;\n    }\n\n    write_f32(v: number) {\n        this.data_view.setFloat32(this.offset, v);\n        this.offset += 4;\n    }\n\n    read_u8() {\n        const result = this.data_view.getUint8(this.offset);\n        this.offset += 1;\n        return result;\n    }\n\n    read_u16() {\n        const result = this.data_view.getUint16(this.offset);\n        this.offset += 2;\n        return result;\n    }\n\n    read_u32() {\n        const result = this.data_view.getUint32(this.offset);\n        this.offset += 4;\n        return result;\n    }\n\n    read_f32() {\n        const result = this.data_view.getFloat32(this.offset);\n        this.offset += 4;\n        return result;\n    }\n\n    read_f64() {\n        const result = this.data_view.getFloat64(this.offset);\n        this.offset += 8;\n        return result;\n    }\n\n    write_f64(v: number) {\n        this.data_view.setFloat64(this.offset, v);\n        this.offset += 8;\n    }\n\n    read_i64() {\n        const result = this.data_view.getBigInt64(this.offset);\n        this.offset += 8;\n        return result;\n    }\n\n    write_i64(v: bigint) {\n        this.data_view.setBigInt64(this.offset, v);\n        this.offset += 8;\n    }\n\n    write_tagged_number(number: number | bigint) {\n        if (typeof number == \"bigint\") {\n            this.write_u8(NumberTag.I64);\n            this.write_i64(number);\n        } else {\n            this.write_u8(NumberTag.F64);\n            this.write_f64(number);\n        }\n    }\n\n    read_tagged_number() {\n        const tag_byte = this.read_u8();\n        if (tag_byte === NumberTag.F64) {\n            return this.read_f64();\n        } else {\n            return this.read_i64();\n        }\n    }\n\n    write_wasm_snapshot(snapshot: WasmSnapshot): void {\n        this.write_time_stamp(snapshot.time_stamp);\n\n        const globals_count = snapshot.globals.length;\n        // Encode all mutable globals\n        this.write_u16(globals_count);\n        for (const value of snapshot.globals) {\n            this.write_u32(value[0]);\n            this.write_tagged_number(value[1] as number | bigint);\n        }\n        this.write_u32(snapshot.memory.byteLength);\n        this.write_raw_bytes(snapshot.memory);\n    }\n\n    read_wasm_snapshot(): WasmSnapshot {\n        const time_stamp = this.read_time_stamp();\n        const mutable_globals_length = this.read_u16();\n\n        const globals: Array<[number, unknown]> = [];\n        for (let i = 0; i < mutable_globals_length; i++) {\n            const index = this.read_u32();\n            const value = this.read_tagged_number();\n            globals.push([index, value]);\n        }\n\n        const bytes_length = this.read_u32();\n        const memory = this.read_fixed_raw_bytes(bytes_length);\n\n        return {\n            memory,\n            globals,\n            time_stamp,\n        };\n    }\n\n    write_time_stamp(time_stamp: TimeStamp) {\n        this.write_f64(time_stamp.time);\n        this.write_f64(time_stamp.player_id);\n    }\n\n    read_time_stamp(): TimeStamp {\n        return {\n            time: this.read_f64(),\n            player_id: this.read_f64()\n        }\n    }\n}\n", "import { MessageWriterReader } from \"./message_encoding\";\nimport { WasmSnapshot } from \"./time_machine\";\n\nconst decoder = new TextDecoder();\n\nexport class RustUtilities {\n    private _rust_utilities: WebAssembly.WebAssemblyInstantiatedSource;\n\n    constructor(rust_utilities: WebAssembly.WebAssemblyInstantiatedSource) {\n        this._rust_utilities = rust_utilities;\n    }\n\n    static async setup(): Promise<RustUtilities> {\n\n        const imports = {\n            env: {\n                external_log: function (pointer: number, length: number) {\n                    const memory = rust_utilities.instance.exports.memory as WebAssembly.Memory;\n                    const message_data = new Uint8Array(memory.buffer, pointer, length);\n                    const decoded_string = decoder.decode(new Uint8Array(message_data));\n                    console.log(decoded_string);\n                },\n                external_error: function (pointer: number, length: number) {\n                    const memory = rust_utilities.instance.exports.memory as WebAssembly.Memory;\n                    const message_data = new Uint8Array(memory.buffer, pointer, length);\n                    const decoded_string = decoder.decode(new Uint8Array(message_data));\n                    console.error(decoded_string);\n                },\n            }\n        };\n        console.log(import.meta);\n\n        const url = new URL(import.meta.url);\n        const url_without_file = url.origin + url.pathname.substring(0, url.pathname.lastIndexOf(\"/\") + 1);\n        const final_url = new URL(\"rust_utilities.wasm\", url_without_file);\n\n        const binary = await fetch(final_url)\n            .then((response) => response.arrayBuffer());\n\n        // TODO: instantiateStreaming would be better here but I was having issues with the mime-type when\n        // hosting on CloudFlare. Investigation needed.\n        const rust_utilities = await WebAssembly.instantiate(binary, imports);\n        return new RustUtilities(rust_utilities);\n    }\n\n    gzip_decode(data_to_decode: Uint8Array) {\n        const memory = this._rust_utilities.instance.exports.memory as WebAssembly.Memory;\n        const instance = this._rust_utilities.instance.exports;\n\n        const pointer = (instance.reserve_space as CallableFunction)(data_to_decode.byteLength);\n        const destination = new Uint8Array(memory.buffer, pointer, data_to_decode.byteLength);\n        destination.set(data_to_decode);\n\n        (instance.gzip_decode as CallableFunction)();\n        const result_pointer = new Uint32Array(memory.buffer, pointer, 2);\n        const result_data = new Uint8Array(memory.buffer, result_pointer[0], result_pointer[1]);\n        return new Uint8Array(result_data);\n    }\n\n\n    // TODO: These are just helpers and aren't that related to the rest of the code in this:\n    gzip_encode(data_to_compress: Uint8Array) {\n        const memory = this._rust_utilities.instance.exports.memory as WebAssembly.Memory;\n        const exports = this._rust_utilities.instance.exports;\n\n        const pointer = (exports.reserve_space as CallableFunction)(data_to_compress.byteLength);\n        const destination = new Uint8Array(memory.buffer, pointer, data_to_compress.byteLength);\n        destination.set(new Uint8Array(data_to_compress));\n\n        (exports.gzip_encode as CallableFunction)();\n        const result_pointer = new Uint32Array(memory.buffer, pointer, 2);\n        const result_data = new Uint8Array(memory.buffer, result_pointer[0], result_pointer[1]);\n        // console.log(\"COMPRESSED LENGTH: \", result_data.byteLength);\n        // console.log(\"COMPRESSION RATIO: \", data_to_compress.byteLength / result_data.byteLength);\n        return result_data;\n    }\n\n    hash_data(...data_to_hash: Array<Uint8Array>): Uint8Array {\n        let byteLength = 0;\n        for (const data of data_to_hash) {\n            byteLength += data.byteLength;\n        }\n\n        const memory = this._rust_utilities.instance.exports.memory as WebAssembly.Memory;\n        const instance = this._rust_utilities.instance.exports;\n\n        const pointer = (instance.reserve_space as CallableFunction)(byteLength);\n\n        let offset = 0;\n        for (const data of data_to_hash) {\n            const destination = new Uint8Array(memory.buffer, pointer + offset, data.byteLength);\n            destination.set(new Uint8Array(data));\n            offset += data.byteLength;\n        }\n        (instance.xxh3_128_bit_hash as CallableFunction)();\n        const hashed_result = new Uint8Array(new Uint8Array(memory.buffer, pointer, 16));\n        return hashed_result;\n    }\n\n    hash_snapshot(wasm_snapshot: WasmSnapshot): Uint8Array {\n        const header = new Uint8Array(2 + wasm_snapshot.globals.length * (4 + 9));\n        const writer = new MessageWriterReader(header);\n\n        const globals_count = wasm_snapshot.globals.length;\n\n        // Encode all mutable globals\n        writer.write_u16(globals_count);\n        for (const value of wasm_snapshot.globals) {\n            writer.write_u32(value[0]);\n            writer.write_tagged_number(value[1] as number | bigint);\n        }\n\n        const result = this.hash_data(writer.get_result_array(), new Uint8Array(wasm_snapshot.memory.buffer));\n        return result;\n    }\n\n    process_binary(wasm_binary: Uint8Array, export_globals: boolean, track_changes: boolean) {\n        if (!(export_globals || track_changes)) {\n            return wasm_binary;\n        }\n\n        const length = wasm_binary.byteLength;\n        const pointer = (this._rust_utilities.instance.exports.reserve_space as CallableFunction)(length);\n\n        const memory = this._rust_utilities.instance.exports.memory as WebAssembly.Memory;\n\n        const data_location = new Uint8Array(memory.buffer, pointer, length);\n        data_location.set(new Uint8Array(wasm_binary));\n        (this._rust_utilities.instance.exports.prepare_wasm as CallableFunction)(export_globals, track_changes);\n\n        // TODO: Write these to an output buffer instead of having two calls for them.\n        const output_ptr = (this._rust_utilities.instance.exports.get_output_ptr as CallableFunction)();\n        const output_len = (this._rust_utilities.instance.exports.get_output_len as CallableFunction)();\n        const output_wasm = new Uint8Array(memory.buffer, output_ptr, output_len);\n        return output_wasm;\n    }\n}", "import { MessageWriterReader } from \"./message_encoding\";\nimport { RustUtilities } from \"./rust_utilities\";\n\nconst WASM_PAGE_SIZE = 65536;\n\nexport type TimeStamp = {\n    time: number,\n    player_id: number,\n};\n\nexport function time_stamp_compare(a: TimeStamp, b: TimeStamp): number {\n    let v = Math.sign(a.time - b.time);\n    if (v != 0) {\n        return v;\n    }\n\n    v = Math.sign(a.player_id - b.player_id);\n    if (v != 0) {\n        return v;\n    }\n\n    return 0;\n}\n\nexport type FunctionCall = {\n    //name: string,\n    function_export_index: number,\n    args: Array<number>,\n    time_stamp: TimeStamp,\n    hash?: Uint8Array\n};\n\nexport type WasmSnapshot = {\n    memory: Uint8Array,\n    // The index in the exports and the value to set the export to\n    globals: Array<[number, unknown]>,\n    time_stamp: TimeStamp\n}\n\ntype Event = FunctionCall;\nconst decoder = new TextDecoder();\n\n// Used for debugging\nlet action_log = \"\";\nconst debug_mode = false;\n\nexport class TimeMachine {\n    _fixed_update_interval?: number;\n\n    private _current_simulation_time: TimeStamp = { time: 0, player_id: 0 };\n    private _fixed_update_time = 0;\n    private _target_time = 0;\n\n    private _need_to_rollback_to_time?: TimeStamp;\n\n    private _events: Array<Event> = [];\n    private _snapshots: Array<WasmSnapshot> = [];\n\n    _wasm_instance: WebAssembly.WebAssemblyInstantiatedSource;\n    private _imports: WebAssembly.Imports = {};\n\n    private _global_indices: Array<number> = [];\n    private _exports: Array<WebAssembly.ExportValue> = [];\n    private _export_keys: Array<string> = [];\n\n    // To facilitate simpler storage, serialization, and networking function calls\n    // are associated with an index instead of a string.\n    private _function_name_to_index: Map<string, number> = new Map();\n    private _fixed_update_index: number | undefined;\n\n    rust_utilities: RustUtilities\n\n    private constructor(wasm_instance: WebAssembly.WebAssemblyInstantiatedSource, rust_utilities: RustUtilities) {\n        this._wasm_instance = wasm_instance;\n        this._exports = Object.values(wasm_instance.instance.exports);\n        this._export_keys = Object.keys(wasm_instance.instance.exports);\n        this.rust_utilities = rust_utilities;\n    }\n\n    static async setup(wasm_binary: Uint8Array, imports: WebAssembly.Imports, fixed_update_interval?: number): Promise<TimeMachine> {\n        const rust_utilities = await RustUtilities.setup();\n\n        // TODO: These imports are for AssemblyScript, but they should be optional\n        // or part of a more fleshed-out strategy for how to manage imports.\n        {\n            imports.env ??= {};\n\n            imports.env.abort ??= () => {\n                console.log(\"Ignoring call to abort\");\n            };\n            imports.env.seed ??= () => {\n                // TODO: Add more entropy\n                return 14;\n            };\n        }\n        let external_log: (a: number, b: number) => void = () => { console.log(\"Not implemented\") };\n        imports.env.external_log ??= (a: number, b: number) => external_log(a, b);\n\n\n        wasm_binary = rust_utilities.process_binary(wasm_binary, true, false);\n        const wasm_instance = await WebAssembly.instantiate(wasm_binary, imports);\n\n        const time_machine = new TimeMachine(wasm_instance, rust_utilities);\n\n        console.log(\"[tangle] Heap size: \", (wasm_instance.instance.exports.memory as WebAssembly.Memory).buffer.byteLength);\n\n        // TODO: Think more about what 'standard library' Wasm should be provided.\n        external_log = (pointer: number, length: number) => {\n            const memory = time_machine._wasm_instance.instance.exports.memory as WebAssembly.Memory;\n            const message_data = new Uint8Array(memory.buffer, pointer, length);\n            const decoded_string = decoder.decode(new Uint8Array(message_data));\n            console.log(decoded_string);\n        };\n\n        // When a module is setup call its main function immediately.\n        // This may only be useful for Rust.\n        {\n            const main = wasm_instance.instance.exports[\"main\"];\n            if (main) {\n                (main as CallableFunction)();\n            }\n        }\n\n        time_machine._imports = imports;\n        time_machine._fixed_update_interval = fixed_update_interval;\n\n        let j = 0;\n        for (const key of Object.keys(wasm_instance.instance.exports)) {\n            if (key.slice(0, 3) == \"wg_\") {\n                time_machine._global_indices.push(j);\n            }\n\n            time_machine._function_name_to_index.set(key, j);\n            if (key == \"fixed_update\") {\n                time_machine._fixed_update_index = j;\n            }\n            j += 1;\n        }\n\n        // Default to 60 frame-per second if unspecified.\n        // If there's no \"fixed_update\" function do not generate 'fixed_update' calls.\n        if (time_machine._fixed_update_index !== undefined) {\n            time_machine._fixed_update_interval ??= 1000 / 60;\n        } else {\n            time_machine._fixed_update_interval = undefined;\n        }\n\n        // This ensures the first message is slightly into the future.\n\n        time_machine._snapshots = [time_machine._get_wasm_snapshot()];\n\n        return time_machine;\n    }\n\n    read_memory(address: number, length: number): Uint8Array {\n        return new Uint8Array(new Uint8Array((this._wasm_instance.instance.exports.memory as WebAssembly.Memory).buffer, address, length));\n    }\n\n    read_string(address: number, length: number): string {\n        const message_data = this.read_memory(address, length);\n        const decoded_string = decoder.decode(new Uint8Array(message_data));\n        return decoded_string;\n    }\n\n    get_function_export_index(function_name: string): number | undefined {\n        return this._function_name_to_index.get(function_name);\n    }\n\n    get_function_name(function_index: number): string | undefined {\n        return this._export_keys[function_index];\n    }\n\n    /// Returns the function call of this instance.\n    async call_with_time_stamp(function_export_index: number, args: Array<number>, time_stamp: TimeStamp) {\n        if (time_stamp_compare(time_stamp, this._snapshots[0].time_stamp) == -1) {\n            // TODO: This is an error. It's no longer possible to add events in the past.\n            // Report a desync here.\n            console.error(\"[tangle error] Attempting to rollback to before earliest safe time\");\n            console.error(\"Event Time: \", time_stamp);\n            console.error(\"Earlieset Snapshot Time: \", this._snapshots[0].time_stamp);\n            throw new Error(\"[tangle error] Attempting to rollback to before earliest safe time\");\n        }\n\n        // To avoid excessive reordering insert recurring function calls that\n        // will occur before this function call.\n        this._progress_recurring_function_calls(time_stamp.time);\n\n        let i = this._events.length - 1;\n        outer_loop:\n        for (; i >= 0; i -= 1) {\n            switch (time_stamp_compare(this._events[i].time_stamp, time_stamp)) {\n                case -1:\n                    // This is where we should insert.\n                    break outer_loop;\n                case 1:\n                    break;\n                case 0: {\n                    const event = this._events[i];\n                    if (function_export_index != event.function_export_index || !(array_equals(args, event.args))) {\n                        // TODO: This is an error! There should not be duplicate time-stamped events.\n                        // Report a desync here.\n                        console.error(\"[tangle error] Attempted to call a function with a duplicate time stamp.\");\n                        console.log(\"Event Time: \", time_stamp);\n                        console.log(\"Function name: \", this.get_function_name(function_export_index));\n                        throw new Error(\"[tangle error] Attempted to call a function with a duplicate time stamp.\");\n                    }\n                    // If this event is a duplicate but is exactly the same as an existing event we can safely ignore it.\n                    return;\n                }\n            }\n        }\n\n        if (time_stamp_compare(time_stamp, this._current_simulation_time) == -1) {\n            // Make sure to rollback to the furthest point in the past that's required. \n            if (this._need_to_rollback_to_time === undefined || time_stamp_compare(time_stamp, this._need_to_rollback_to_time) == -1) {\n                // This will cause a rollback next time `simulate_forward` is called.\n                this._need_to_rollback_to_time = time_stamp;\n            }\n        }\n\n        const event = {\n            function_export_index,\n            args,\n            time_stamp,\n        };\n        // Insert after the found insertion point.\n        this._events.splice(i + 1, 0, event);\n\n        if (debug_mode) {\n            action_log += `Inserting call ${i + 1} ${event.time_stamp.time} ${event.time_stamp.player_id} ${this.get_function_name(event.function_export_index)}\\n`\n        }\n    }\n\n    /// Call a function but ensure its results do not persist and cannot cause a desync.\n    /// This can be used for things like drawing or querying from the Wasm\n    async call_and_revert(function_export_index: number, args: Array<number>) {\n        const f = this._exports[function_export_index] as CallableFunction;\n\n        if (f) {\n            const snapshot = this._get_wasm_snapshot();\n            (f as CallableFunction)(...args);\n            await this._apply_snapshot(snapshot);\n        }\n    }\n\n    private _progress_recurring_function_calls(target_time: number) {\n        if (this._fixed_update_interval !== undefined && this._fixed_update_index !== undefined) {\n            // Add `fixed_update` calls that go into the future.\n            while (target_time > this._fixed_update_time) {\n                this.call_with_time_stamp(this._fixed_update_index, [], { time: this._fixed_update_time, player_id: 0 });\n                this._fixed_update_time += this._fixed_update_interval;\n            }\n        }\n    }\n\n    target_time(): number {\n        return this._target_time;\n    }\n\n    // This is used in scenarios where a peer falls too far behind in a simulation. \n    // This lets them have normal visuals until they resync.\n    set_target_time(time: number) {\n        this._target_time = time;\n    }\n\n    current_simulation_time(): number {\n        return this._current_simulation_time.time;\n    }\n\n    /// This lets the simulation run further into the future.\n    /// No functions are actually called yet, that's the responsibility of `step`\n    progress_time(time: number) {\n        this._target_time += time;\n        this._progress_recurring_function_calls(this._target_time);\n    }\n\n    /// Simulates one function step forward and returns if there's more work to do.\n    /// This gives the calling context an opportunity to manage how much CPU-time is consumed.\n    /// Call this is in a loop and if it returns true continue. \n    step(): boolean {\n        if (this._need_to_rollback_to_time !== undefined) {\n            // Perform a rollback here.\n\n            if (debug_mode) {\n                action_log += `Target rollback time: ${this._need_to_rollback_to_time.time} ${this._need_to_rollback_to_time.player_id}\\n`;\n            }\n            // Apply the most recent snapshot.\n            let i = this._snapshots.length - 1;\n            for (; i >= 0; --i) {\n                if (time_stamp_compare(this._need_to_rollback_to_time, this._snapshots[i].time_stamp) != -1) {\n                    break;\n                }\n            }\n\n            const snap_shot = this._snapshots[i];\n            this._apply_snapshot(snap_shot);\n\n            // Remove future snapshots\n            this._snapshots.splice(i, this._snapshots.length - i);\n\n            if (debug_mode) {\n                action_log += `Rolling back to: ${snap_shot.time_stamp.time} ${snap_shot.time_stamp.player_id}\\n`;\n            }\n\n            // Begin simulation from the event that occurred after the snapshot rolled back to.\n            this._current_simulation_time = snap_shot.time_stamp;\n            this._need_to_rollback_to_time = undefined;\n        }\n\n        let i = this._events.length - 1;\n        for (; i >= 0; --i) {\n            if (time_stamp_compare(this._events[i].time_stamp, this._current_simulation_time) != 1) {\n                break;\n            }\n        }\n        i += 1;\n\n        const function_call = this._events[i];\n        if (function_call !== undefined && function_call.time_stamp.time <= this._target_time) {\n            const f = this._exports[function_call.function_export_index] as CallableFunction;\n\n            f(...function_call.args);\n\n            if (debug_mode) {\n                function_call.hash = this.hash_wasm_state();\n            }\n\n            if (action_log) {\n                const event = function_call;\n                action_log += `i ${event.time_stamp.time} ${event.time_stamp.player_id} ${this.get_function_name(event.function_export_index)} ${event.hash}\\n`\n            }\n\n            this._current_simulation_time = function_call.time_stamp;\n            return true;\n        }\n        return false;\n    }\n\n    // Take a snapshot. This provides a point in time to rollback to.\n    // This should be called after significant computation has been performed.\n    take_snapshot() {\n        let i = this._events.length - 1;\n        for (; i >= 0; --i) {\n            const compare = time_stamp_compare(this._events[i].time_stamp, this._current_simulation_time);\n            if (compare == -1) {\n                return;\n            }\n            if (compare == 0) {\n                this._snapshots.push(this._get_wasm_snapshot());\n                // There is no need to store the function anymore after this, so remove it from the events array.\n                return;\n            }\n        }\n    }\n\n    remove_history_before(time: number) {\n        if (debug_mode) {\n            return;\n        }\n\n        // Remove all events and snapshots that occurred before this time.\n        // Progress the safe time. \n        // Always leave at least one snapshot to rollback to.\n\n        let i = 0;\n        // To ensure there's always atleast one snapshot to rollback to:\n        // this._snapshots.length - 1 \n        for (; i < this._snapshots.length - 1; ++i) {\n            if (this._snapshots[i].time_stamp.time >= time) {\n                break;\n            }\n        }\n        i -= 1;\n        this._snapshots.splice(0, i);\n\n        // Remove all events that occurred before the latest snapshot.\n        let j = 0;\n        for (; j < this._events.length; ++j) {\n            if (time_stamp_compare(this._events[j].time_stamp, this._snapshots[0].time_stamp) != -1) {\n                break;\n            }\n        }\n        j -= 1;\n        this._events.splice(0, j);\n    }\n\n    // `deep` specifies if the memory is deep-copied for this snapshot. \n    private _get_wasm_snapshot(deep = true): WasmSnapshot {\n        const globals: Array<[number, unknown]> = [];\n\n        const export_values = Object.values(this._wasm_instance.instance.exports);\n        for (const index of this._global_indices) {\n            globals.push([index, (export_values[index] as WebAssembly.Global).value]);\n        }\n\n        let memory = new Uint8Array((this._wasm_instance.instance.exports.memory as WebAssembly.Memory).buffer);\n        if (deep) {\n            memory = new Uint8Array(memory);\n        }\n\n        // console.log(\"TOTAL SIZE: \", this._snapshots.length * memory.byteLength);\n\n        return {\n            // This nested Uint8Array constructor creates a deep copy.\n            memory,\n            globals,\n            time_stamp: this._current_simulation_time\n        };\n    }\n\n    private async _apply_snapshot(snapshot: WasmSnapshot) {\n        this._assign_memory(snapshot.memory);\n\n        const values = Object.values(this._wasm_instance.instance.exports);\n\n        for (let j = 0; j < snapshot.globals.length; j++) {\n            (values[snapshot.globals[j][0]] as WebAssembly.Global).value = snapshot.globals[j][1];\n        }\n    }\n\n    private async _assign_memory(new_memory_data: Uint8Array) {\n        const mem = this._wasm_instance?.instance.exports.memory as WebAssembly.Memory;\n        let page_diff = (new_memory_data.byteLength - mem.buffer.byteLength) / WASM_PAGE_SIZE;\n\n        // The only way to \"shrink\" a Wasm instance is to construct an entirely new \n        // one with a new memory.\n        // Hopefully Wasm gets a better way to shrink instances in the future.\n\n        if (page_diff < 0) {\n            const old_instance = this._wasm_instance.instance;\n            this._wasm_instance.instance = await WebAssembly.instantiate(this._wasm_instance.module, this._imports);\n            page_diff = (new_memory_data.byteLength - (this._wasm_instance?.instance.exports.memory as WebAssembly.Memory).buffer.byteLength) / WASM_PAGE_SIZE;\n\n            // Copy over all globals during the resize.\n            for (const [key, v] of Object.entries(old_instance.exports)) {\n                if (key.slice(0, 3) == \"wg_\") {\n                    (this._wasm_instance.instance.exports[key] as WebAssembly.Global).value = v;\n                }\n            }\n\n            // TODO: Copy mutable Wasm tables as well.\n        }\n\n        const old_memory = this._wasm_instance?.instance.exports.memory as WebAssembly.Memory;\n        if (page_diff > 0) {\n            old_memory.grow(page_diff);\n        }\n        new Uint8Array(old_memory.buffer).set(new_memory_data);\n    }\n\n    encode(first_byte: number): Uint8Array {\n        console.log(\"[time-machine] Encoding with hash: \", this.hash_wasm_state());\n\n        // For bandwidth / performance reasons only send encode\n        // the earliest safe snapshot and all subsequent events.\n        // It's up to the decoding TimeMachine to catchup.\n        const snapshot = this._snapshots[0];\n\n        let size = 1 + 8 * 4 + 4 + (4 + 8 + 8 + 1) * this._events.length;\n        for (const event of this._events) {\n            size += event.args.length * 8;\n        }\n        size += 8 + 8 + 2 + (4 + 9) * snapshot.globals.length;\n        size += 4 + snapshot.memory.buffer.byteLength;\n\n        const writer = new MessageWriterReader(new Uint8Array(size));\n\n        writer.write_u8(first_byte);\n\n        // Encode _earliest_safe_time\n        // Encode _fixed_update_time\n        // Encode _target_time\n        // Encode _next_run_event_index\n        // Encode _events\n        // Encode _snapshot\n\n        writer.write_f64(this._fixed_update_time);\n        writer.write_f64(this._target_time);\n        writer.write_time_stamp(snapshot.time_stamp);\n\n        // Encode events\n        writer.write_u32(this._events.length);\n        for (const event of this._events) {\n            writer.write_u32(event.function_export_index);\n            writer.write_time_stamp(event.time_stamp);\n            writer.write_u8(event.args.length);\n            for (const arg of event.args) {\n                writer.write_f64(arg);\n            }\n        }\n\n        // Encode the snapshot\n        writer.write_wasm_snapshot(snapshot);\n\n        // Debugging\n        console.log(\"[time-machine] Hash of sent snapshot: \", this.rust_utilities.hash_snapshot(snapshot));\n\n        return writer.get_result_array();\n    }\n\n    decode_and_apply(reader: MessageWriterReader) {\n        this._fixed_update_time = reader.read_f64();\n        this._target_time = reader.read_f64();\n        this._current_simulation_time = reader.read_time_stamp();\n\n        const events_length = reader.read_u32();\n        this._events = new Array(events_length);\n\n        let last_time_stamp = {\n            time: -1,\n            player_id: 0,\n        };\n        for (let i = 0; i < events_length; ++i) {\n            const function_export_index = reader.read_u32();\n            const time_stamp = reader.read_time_stamp();\n\n            const args_length = reader.read_u8();\n            const args = new Array(args_length);\n            for (let j = 0; j < args_length; ++j) {\n                args[j] = reader.read_f64();\n            }\n            this._events[i] = {\n                function_export_index,\n                time_stamp,\n                args,\n            };\n\n            if (!(time_stamp_compare(last_time_stamp, time_stamp) == -1)) {\n                console.log(\"ERROR: INCOMING TIME STAMPS OUT OF ORDER\");\n            }\n            last_time_stamp = time_stamp;\n        }\n\n        const wasm_snapshot = reader.read_wasm_snapshot();\n\n        // Evaluate if WasmSnapshot really needs to have a TimeStamp.\n        this._apply_snapshot(wasm_snapshot);\n        this._snapshots = [wasm_snapshot];\n\n        console.log(\"[time-machine] Decoded with hash: \", this.hash_wasm_state());\n    }\n\n    hash_wasm_state(): Uint8Array {\n        return this.rust_utilities.hash_snapshot(this._get_wasm_snapshot(false));\n    }\n\n    print_history() {\n        let history = \"\";\n        let previous_time_stamp = { time: -1, player_id: 0 };\n        for (const event of this._events) {\n            if (time_stamp_compare(previous_time_stamp, event.time_stamp) != -1) {\n                history += \"ERROR: OUT OF ORDER TIMESTAMPS\\n\";\n            }\n            history += `${event.time_stamp.time} ${event.time_stamp.player_id} ${this.get_function_name(event.function_export_index)} ${event.hash}\\n`\n            previous_time_stamp = event.time_stamp;\n        }\n        console.log(action_log);\n        console.log(history);\n    }\n\n}\n\nfunction array_equals(a: number[], b: number[]) {\n    return a.length === b.length &&\n        a.every((val, index) => val === b[index]);\n}\n", "import { PeerId, Room, RoomState } from \"./room.js\";\nimport { TimeMachine, FunctionCall } from \"./time_machine\";\nimport { RustUtilities } from \"./rust_utilities.js\";\nimport { MessageWriterReader } from \"./message_encoding.js\";\n\nexport { RoomState, PeerId } from \"./room.js\";\n\nenum MessageType {\n    WasmCall,\n    TimeProgressed,\n    RequestState,\n    SetProgram,\n    SetHeap,\n    // Used to figure out roundtrip time.\n    Ping,\n    Pong\n}\n\ntype PeerData = {\n    last_sent_message: number,\n    last_received_message: number,\n    round_trip_time: number,\n    // When the current time was measured\n    estimated_current_time_measurement: number,\n    // Based on round trip latency this is an estimate of the remote peer's perceived current time.\n    estimated_current_time?: number\n}\n\nexport enum TangleState {\n    Disconnected,\n    Connected,\n    RequestingHeap\n}\n\ntype TangleConfiguration = {\n    fixed_update_interval?: number;\n    accept_new_programs?: boolean,\n    room_name?: string,\n    ice_servers?: RTCIceServer[],\n    room_server?: string,\n    on_state_change_callback?: (state: TangleState, tangle: Tangle) => void\n}\n\ntype InstantiatedTangle = {\n    instance: {\n        // TODO: More explicit types, don't use `any`\n        exports: Record<string, any>,\n    },\n    tangle: Tangle\n}\n\nclass UserIdType { }\nexport const UserId = new UserIdType();\n\nconst ROUND_TRIP_TIME_ROLLING_AVERAGE_ALPHA = 0.9;\n\nexport class Tangle {\n    private _room!: Room;\n    private _time_machine!: TimeMachine;\n    private _rust_utilities: RustUtilities;\n\n    private _buffered_messages: Array<FunctionCall> = [];\n    private _peer_data: Map<PeerId, PeerData> = new Map();\n    private _tangle_state = TangleState.Disconnected;\n    private _current_program_binary = new Uint8Array();\n    private _block_reentrancy = false;\n    private _enqueued_inner_calls: Array<() => void> = [];\n    private _last_performance_now?: number;\n    private _configuration: TangleConfiguration = {};\n    private _outgoing_message_buffer = new Uint8Array(500);\n\n    private _message_time_offset = 0;\n\n    // private _debug_enabled = true;\n\n    static async instanstiate(source: ArrayBuffer, importObject?: WebAssembly.Imports | undefined, tangle_configuration?: TangleConfiguration): Promise<InstantiatedTangle> {\n        tangle_configuration ??= {};\n        tangle_configuration.accept_new_programs ??= false;\n\n        const wasm_binary = new Uint8Array(source);\n\n        importObject ??= {};\n\n        // Wrap all imports so that they can't return a value, which would cause desyncs.\n        // This may need more thought in the future because it's a big limitation.\n        if (importObject) {\n            Object.values(importObject).forEach((moduleImports) => {\n                Object.entries(moduleImports).forEach(([importName, importValue]) => {\n                    if (typeof importValue === 'function') {\n                        moduleImports[importName] = function (...args: any) {\n                            const r = importValue(...args);\n                            if (r !== undefined) {\n                                console.log(\"[tangle warning] Tangle prevents WebAssembly imports from returning values because those values are unique per-peer and would cause a desync.\")\n                            }\n                        };\n                    }\n                });\n            });\n        }\n\n        const time_machine = await TimeMachine.setup(wasm_binary, importObject, tangle_configuration.fixed_update_interval);\n\n        const tangle = new Tangle(time_machine);\n        tangle._configuration = tangle_configuration;\n        const exports = await tangle.setup_inner(tangle_configuration.room_name, wasm_binary);\n        return {\n            instance: {\n                exports\n            },\n            tangle: tangle\n        };\n    }\n\n    static async instantiateStreaming(source: Response | PromiseLike<Response>, importObject?: WebAssembly.Imports | undefined, tangle_configuration?: TangleConfiguration): Promise<InstantiatedTangle> {\n        source = await source;\n        const binary = await source.arrayBuffer();\n        return Tangle.instanstiate(new Uint8Array(binary), importObject, tangle_configuration);\n    }\n\n    constructor(time_machine: TimeMachine) {\n        this._time_machine = time_machine;\n        this._rust_utilities = time_machine.rust_utilities;\n    }\n\n    private _change_state(state: TangleState) {\n        if (this._tangle_state != state) {\n            if (state == TangleState.Connected) {\n                this._last_performance_now = performance.now();\n            }\n            this._tangle_state = state;\n            this._configuration.on_state_change_callback?.(state, this);\n        }\n        this._tangle_state = state\n    }\n\n    private async setup_inner(room_name: string | undefined, wasm_binary: Uint8Array): Promise<Record<string, any>> {\n        room_name ??= document.location.href;\n\n        // Append a hash of the binary so that peers won't join rooms without matching binaries.\n        const hash = this._rust_utilities.hash_data(wasm_binary);\n        room_name += hash.join(\"\");\n\n        const room_configuration = {\n            server_url: this._configuration.room_server,\n            ice_servers: this._configuration.ice_servers,\n            room_name,\n            on_peer_joined: (peer_id: PeerId) => {\n                this._peer_data.set(peer_id, {\n                    last_sent_message: 0,\n                    last_received_message: 0,\n                    round_trip_time: 0,\n                    estimated_current_time_measurement: 0,\n                    estimated_current_time: undefined\n                });\n                this._room.send_message(this._encode_ping_message(), peer_id);\n            },\n            on_peer_left: (peer_id: PeerId) => {\n                this._run_inner_function(async () => {\n                    this._peer_data.delete(peer_id);\n\n                    // TODO: This is a terrible way to handle peer disconnects.\n                    // It has many potential unhandled edge-cases, but will work most of the time for now.\n\n                    // Only one peer in the room will issue a `peer_left` event.\n                    let closest_peer = this._room.my_id;\n                    let peer_distance = this._room.my_id - peer_id;\n\n                    for (const peer of this._peer_data.keys()) {\n                        const diff = peer - peer_id;\n                        if (diff != 0 && diff < peer_distance) {\n                            closest_peer = peer;\n                            peer_distance = diff;\n                        }\n                    }\n\n                    console.log(\"[tangle] calling 'peer_left'\");\n                    if (closest_peer == this._room.my_id) {\n                        this.call(\"peer_left\", peer_id);\n                    }\n                });\n            },\n            on_state_change: (state: RoomState) => {\n                this._run_inner_function(async () => {\n                    console.log(\"[tangle] Room state changed: \", RoomState[state]);\n\n                    switch (state) {\n                        case RoomState.Connected: {\n                            this._request_heap();\n\n                            if (this._peer_data.size == 0) {\n                                // We have no peer so we're connected\n                                this._change_state(TangleState.Connected);\n                            }\n                            break;\n                        }\n                        case RoomState.Disconnected: {\n                            this._change_state(TangleState.Disconnected);\n                            break;\n                        }\n                        case RoomState.Joining: {\n                            this._change_state(TangleState.Disconnected);\n                            break;\n                        }\n                    }\n\n                });\n            },\n            on_message: async (peer_id: PeerId, message: Uint8Array) => {\n                const peer_connected_already = this._peer_data.get(peer_id);\n\n                this._run_inner_function(async () => {\n                    // Ignore messages from peers that have disconnected. \n                    // TODO: Evaluate if this could cause desyncs.\n                    const peer = this._peer_data.get(peer_id);\n                    if (!peer) {\n                        console.log(\"[tangle] Rejected message from unconnected peer: \", peer_id);\n                        return;\n                    }\n\n                    const message_type = message[0];\n                    const message_data = message.subarray(1);\n\n                    switch (message_type) {\n                        case (MessageType.TimeProgressed): {\n                            const time = this._decode_time_progressed_message(message_data);\n                            peer.last_received_message = time;\n                            break;\n                        }\n                        case (MessageType.WasmCall): {\n                            const m = this._decode_wasm_call_message(message_data);\n                            peer.last_received_message = m.time;\n\n                            const time_stamp = {\n                                time: m.time,\n                                player_id: peer_id\n                            };\n\n                            if (this._tangle_state == TangleState.RequestingHeap) {\n                                this._buffered_messages.push({\n                                    function_export_index: m.function_index,\n                                    time_stamp: time_stamp,\n                                    args: m.args\n                                });\n                            } else {\n                                console.log(\"Remote Wasm call: \", this._time_machine.get_function_name(m.function_index));\n                                await this._time_machine.call_with_time_stamp(m.function_index, m.args, time_stamp);\n                                if (!(this._time_machine._fixed_update_interval)) {\n                                    this.progress_time();\n                                }\n                            }\n\n                            break;\n                        }\n                        case (MessageType.RequestState): {\n                            // TODO: Check that this is a fully loaded peer.\n                            const heap_message = this._time_machine.encode(MessageType.SetHeap);\n                            this._room.send_message(heap_message);\n                            break;\n                        }\n                        case (MessageType.SetHeap): {\n                            if (this._tangle_state != TangleState.Connected) {\n                                console.log(\"[tangle] Applying TimeMachine state from peer\");\n\n                                const round_trip_time = peer.round_trip_time;\n                                console.log(\"[tangle] Approximate round trip offset: \", round_trip_time / 2);\n                                this._time_machine.decode_and_apply(new MessageWriterReader(message_data));\n\n                                // Apply any messages that were received as we were waiting for this to load.\n                                for (const m of this._buffered_messages) {\n                                    await this._time_machine.call_with_time_stamp(m.function_export_index, m.args, m.time_stamp);\n                                }\n                                this._buffered_messages = [];\n\n                                // Progress the target time to approximately catch up to the remote peer.\n                                this._time_machine.progress_time(round_trip_time / 2);\n\n                                this._change_state(TangleState.Connected);\n                            }\n                            break;\n                        }\n                        case (MessageType.Ping): {\n                            const writer = new MessageWriterReader(this._outgoing_message_buffer);\n                            writer.write_u8(MessageType.Pong);\n                            writer.write_raw_bytes(message_data);\n                            // Send the average of the peers current times\n                            // This should help peers converge on a common sense of time.\n                            writer.write_f64(this._average_current_time(performance.now()));\n                            this._room.send_message(writer.get_result_array(), peer_id);\n                            break;\n                        }\n                        case (MessageType.Pong): {\n                            // TODO: Check that the peer hasn't messed with this message's time.\n                            const { time_sent, current_time } = this._decode_pong_message(message_data);\n                            const new_round_trip_time = Date.now() - time_sent;\n                            if (peer.round_trip_time == 0) {\n                                peer.round_trip_time = new_round_trip_time;\n                            } else {\n                                peer.round_trip_time = peer.round_trip_time\n                                    * ROUND_TRIP_TIME_ROLLING_AVERAGE_ALPHA\n                                    + (1.0 - ROUND_TRIP_TIME_ROLLING_AVERAGE_ALPHA) * new_round_trip_time;\n                            }\n                            peer.estimated_current_time = current_time + peer.round_trip_time / 2;\n                            peer.estimated_current_time_measurement = performance.now();\n                            break;\n                        }\n                    }\n                }, !peer_connected_already);\n            }\n        };\n\n        this._room = await Room.setup(room_configuration, this._rust_utilities);\n        this._current_program_binary = wasm_binary;\n\n        const export_object: Record<string, any> = {};\n        for (const key of Object.keys(this._time_machine._wasm_instance.instance.exports)) {\n            const e = this._time_machine._wasm_instance.instance.exports[key];\n            if (typeof e === 'function') {\n                const wrapped_function = (...args: any) => {\n                    this.call(key, ...args);\n                };\n                wrapped_function.callAndRevert = (...args: any) => {\n                    this.call_and_revert(key, ...args);\n                };\n                export_object[key] = wrapped_function;\n            }\n        }\n        return export_object;\n    }\n\n    private async _run_inner_function(f: () => void, enqueue_condition = false) {\n        if (!this._block_reentrancy && !enqueue_condition) {\n            this._block_reentrancy = true;\n            await f();\n            let f1 = this._enqueued_inner_calls.shift();\n            while (f1) {\n                await f1();\n                f1 = this._enqueued_inner_calls.shift();\n            }\n            this._block_reentrancy = false;\n        } else {\n            this._enqueued_inner_calls.push(f);\n        }\n    }\n\n    private _request_heap() {\n        // Ask an arbitrary peer for the heap\n        const lowest_latency_peer = this._room.get_lowest_latency_peer();\n        if (lowest_latency_peer) {\n            this._change_state(TangleState.RequestingHeap);\n            this._room.send_message(this._encode_ping_message(), lowest_latency_peer);\n            this._room.send_message(this._encode_request_heap_message(), lowest_latency_peer);\n        }\n    }\n\n    private _encode_wasm_call_message(function_index: number, time: number, args: Array<number> /*, hash?: Uint8Array*/): Uint8Array {\n        const message_writer = new MessageWriterReader(this._outgoing_message_buffer);\n        message_writer.write_u8(MessageType.WasmCall);\n\n        message_writer.write_u32(function_index);\n        message_writer.write_f64(time);\n        message_writer.write_u8(args.length);\n\n\n        // Encode args. \n        // TODO: For now all args are encoded as f64s, but that is incorrect.\n        for (let i = 0; i < args.length; i++) {\n            message_writer.write_f64(args[i]);\n        }\n\n        /*\n        if (this._debug_enabled) {\n            message_writer.write_raw_bytes(hash!);\n        }\n        */\n\n        return this._outgoing_message_buffer.subarray(0, message_writer.offset);\n    }\n\n    private _decode_wasm_call_message(data: Uint8Array) {\n        const message_reader = new MessageWriterReader(data);\n\n        const function_index = message_reader.read_u32();\n        const time = message_reader.read_f64();\n        const args_length = message_reader.read_u8();\n\n        const args = new Array<number>(args_length);\n        for (let i = 0; i < args.length; i++) {\n            args[i] = message_reader.read_f64();\n        }\n\n        let hash;\n\n        /*\n        let hash;\n        if (this._debug_enabled) {\n            hash = message_reader.read_fixed_raw_bytes(16);\n        }\n        */\n\n        return {\n            function_index,\n            time,\n            args,\n            hash\n        };\n    }\n\n    private _encode_time_progressed_message(time_progressed: number): Uint8Array {\n        const message_writer = new MessageWriterReader(this._outgoing_message_buffer);\n        message_writer.write_u8(MessageType.TimeProgressed);\n        message_writer.write_f64(time_progressed);\n        return message_writer.get_result_array();\n    }\n\n    private _decode_time_progressed_message(data: Uint8Array) {\n        return new DataView(data.buffer, data.byteOffset).getFloat64(0);\n    }\n\n    private _encode_request_heap_message(): Uint8Array {\n        this._outgoing_message_buffer[0] = MessageType.RequestState;\n        return this._outgoing_message_buffer.subarray(0, 1);\n    }\n\n    private _encode_ping_message(): Uint8Array {\n        const writer = new MessageWriterReader(this._outgoing_message_buffer);\n        writer.write_u8(MessageType.Ping);\n        writer.write_f64(Date.now());\n        return writer.get_result_array();\n    }\n\n    private _decode_pong_message(data: Uint8Array): { time_sent: number, current_time: number } {\n        const reader = new MessageWriterReader(data);\n        const time_sent = reader.read_f64();\n        const current_time = reader.read_f64();\n        return { time_sent, current_time }\n    }\n\n    private _process_args(args: Array<number | UserIdType>): Array<number> {\n        return args.map((a) => {\n            if (typeof a != \"number\") {\n                // Assume this is a UserId\n                return this._room.my_id;\n            } else {\n                return a;\n            }\n        });\n    }\n\n    private _median_round_trip_latency(): number | undefined {\n        const latencies = Array.from(this._peer_data.values()).map((peer) => peer.round_trip_time).sort();\n        return latencies[Math.floor(latencies.length / 2)];\n    }\n\n    call(function_name: string, ...args: Array<number | UserIdType>) {\n        this._run_inner_function(async () => {\n\n            // TODO: Only process the args like this for local calls.\n            // Let remote calls insert the ID themselves\n            // As-is this design makes it trivial for peers to spoof each-other.\n            const args_processed = this._process_args(args);\n\n            // TODO: This is very arbitrary. \n            // TODO: This trusts the high-latency peer to be well-behaved, there should be a way for the room to enforce this.\n            // This adds some latency to very laggy peers to make rollbacks less likely.\n            let median_round_trip_latency = this._median_round_trip_latency();\n            if (median_round_trip_latency === undefined || median_round_trip_latency < 60) {\n                median_round_trip_latency = 0;\n            }\n            median_round_trip_latency = Math.min(median_round_trip_latency, 200);\n\n            // TODO: If median_round_trip_latency changes a lot this could violate the rule of never sending messages with past time-stamps.\n            const time_stamp = {\n                time: this._time_machine.target_time() + this._message_time_offset + median_round_trip_latency / 2,\n                player_id: this._room.my_id\n            };\n\n            // Ensure events each have a unique timestamp.\n            // In practice this tiny offset should be of no consequence.\n            this._message_time_offset += .0001;\n\n            const function_index = this._time_machine.get_function_export_index(function_name);\n            if (function_index !== undefined) {\n                await this._time_machine.call_with_time_stamp(function_index, args_processed, time_stamp);\n\n                // Do not send events to the room if we're not yet fully connected.\n                if (this._tangle_state == TangleState.Connected) {\n                    // Network the call\n                    // TODO: These ping messages do not need to be sent so frequently or can be bundled with other messages.\n                    this._room.send_message(this._encode_ping_message());\n                    this._room.send_message(this._encode_wasm_call_message(function_index, time_stamp.time, args_processed));\n                }\n\n                for (const value of this._peer_data.values()) {\n                    value.last_sent_message = Math.max(value.last_received_message, time_stamp.time);\n                }\n            }\n        });\n\n        this.progress_time();\n    }\n\n    /// This call will have no impact but can be useful to draw or query from the world.\n    call_and_revert(function_name: string, ...args: Array<number>) {\n        this.progress_time();\n\n        this._run_inner_function(async () => {\n            const args_processed = this._process_args(args);\n            const function_index = this._time_machine.get_function_export_index(function_name);\n            if (function_index) {\n                this._time_machine.call_and_revert(function_index, args_processed);\n            }\n        });\n    }\n\n    /// Resync with the room, immediately catching up.\n    resync() {\n        this._run_inner_function(() => {\n            this._request_heap();\n        });\n    }\n\n    progress_time() {\n        this._run_inner_function(async () => {\n            await this._progress_time_inner();\n        });\n    }\n\n    private async _progress_time_inner() {\n        const performance_now = performance.now();\n\n        if (this._last_performance_now) {\n            const average_current_time = this._average_current_time(performance_now);\n            const difference_from_peers = average_current_time - this.current_time(performance_now);\n\n            let time_progressed = performance_now - this._last_performance_now + difference_from_peers;\n            console.log(\"DIFFERENCE FROM PEERS: \", difference_from_peers);\n            //console.log(\"TIME PROGRESSED: \", time_progressed);\n            // Time cannot flow backwards.\n            time_progressed = Math.max(time_progressed, 0.0001);\n\n            const check_for_resync = true;\n            if (check_for_resync) {\n                // If the client is the threshold behind assume they need to be resynced.\n                const time_diff = (this._time_machine.target_time() + time_progressed) - this._time_machine.current_simulation_time();\n                if (this._time_machine._fixed_update_interval !== undefined && time_diff > 3000) {\n\n                    // TODO: This time change means that this peer cannot be trusted as an authority on the room simulation.\n                    // The peer should stop sending events and should absolutely not synchronize state with other peers.\n                    // TODO: If a peer that's fallen behind receives a snapshot from another peer that's fallen behind\n                    // that can cause an infinite loop between the peers.\n                    time_progressed = this._time_machine._fixed_update_interval;\n\n                    if (this._peer_data.size > 0) {\n                        // TODO: Resync instead of reload.\n                        location.reload();\n                        console.log(\"[tangle] Fallen behind, reloading room\");\n                        // this._request_heap();\n                    } else {\n                        console.log(\"[tangle] Fallen behind but this is a single-player session, so ignoring this\");\n                    }\n                }\n            }\n\n            await this._time_machine.progress_time(time_progressed);\n\n            const time_budget = time_progressed * 0.7;\n            const time_here = performance.now();\n\n            while (this._time_machine.step()) {\n                // TODO: A better heuristic for when snapshots should be taken.\n                // They could be taken after a set amount of computational overhead.\n                // Taking a snapshot here is extremely costly!\n                this._time_machine.take_snapshot();\n                if ((performance.now() - time_here) > time_budget) {\n                    break;\n                }\n            }\n\n            // Remove history that's safe to remove.\n\n            // Keep track of when a message was received from each peer\n            // and use that to determine what history is safe to throw away.\n            let earliest_safe_memory = this._time_machine.current_simulation_time();\n\n            if (this._tangle_state == TangleState.Connected) {\n                for (const [peer_id, value] of this._peer_data) {\n                    earliest_safe_memory = Math.min(earliest_safe_memory, value.last_received_message);\n                    // If we haven't messaged our peers in a while send them a message\n                    // This lets them know nothing has happened and they can discard history.\n                    // I suspect the underlying RTCDataChannel protocol is sending keep alives as well,\n                    // it'd be better to figure out if those could be used instead.\n                    const KEEP_ALIVE_THRESHOLD = 200;\n                    const current_time = this._time_machine.target_time();\n                    const difference = (current_time - value.last_sent_message);\n                    if (difference > KEEP_ALIVE_THRESHOLD) {\n                        // TODO: These ping messages do not need to be sent so frequently or can be bundled with other messages.\n                        this._room.send_message(this._encode_ping_message(), peer_id);\n                        this._room.send_message(this._encode_time_progressed_message(current_time), peer_id);\n                    }\n\n                    if (difference <= 0) {\n                        console.error(\"SHOULD NOT BE HERE!\");\n                    }\n                }\n            }\n\n            // TODO: The -50 here is masking some sort of bug where a crash occurs because there's no available snapshot.\n            this._time_machine.remove_history_before(earliest_safe_memory);\n\n            if (time_progressed > 0) {\n                this._message_time_offset = 0;\n            }\n        }\n\n        this._last_performance_now = performance_now;\n    }\n\n    _average_current_time(now: number): number {\n        let current_time = this._time_machine.target_time();\n        if (this._last_performance_now) {\n            current_time += now - this._last_performance_now;\n        }\n\n        let count = 1;\n        for (const peer of this._peer_data.values()) {\n            if (peer.estimated_current_time) {\n                current_time += peer.estimated_current_time + (now - peer.estimated_current_time_measurement);\n                count += 1;\n            }\n        }\n        current_time = current_time / count;\n        return current_time;\n    }\n\n    current_time(now: number): number {\n        let time = this._time_machine.target_time();\n        if (this._last_performance_now) {\n            time += now - this._last_performance_now;\n        }\n        return time;\n    }\n\n    read_memory(address: number, length: number): Uint8Array {\n        return this._time_machine.read_memory(address, length);\n    }\n    read_string(address: number, length: number): string {\n        return this._time_machine.read_string(address, length);\n    }\n\n    print_history() {\n        this._time_machine.print_history();\n    }\n}\n\n", "import { Tangle, TangleState, UserId } from \"../tangle/tangle_ts/src/index\";\n\nasync function setup_demo1() {\n    let extra_elements: Array<Element> = [];\n\n    let canvas = document.getElementById(\"demo1\")! as HTMLCanvasElement;\n    canvas.style.opacity = \"0.0\";\n\n    var context = canvas.getContext(\"2d\")!;\n\n    let fixed_update_interval = 1000 / 60;\n\n    function addEmoji(emoji: string, x: number, y: number): Element {\n        let emojiElement = document.createElement(\"div\");\n        emojiElement.style.position = \"absolute\";\n        emojiElement.style.left = x + \"px\";\n        emojiElement.style.top = y + \"px\";\n        emojiElement.style.display = \"flex\";\n        emojiElement.style.justifyContent = \"center\";\n        emojiElement.style.alignItems = \"center\";\n        emojiElement.style.fontSize = \"35px\";\n        emojiElement.innerText = emoji;\n        emojiElement.style.transform = \"translate(-50%, -50%)\";\n        document.body.appendChild(emojiElement);\n        return emojiElement;\n    }\n\n    function addSVGArrow(x1: number, y1: number, x2: number, y2: number): Element {\n        const stroke_width = 6;\n        const padding = 20;\n        const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n        svg.setAttribute(\"style\", \"position: absolute;\");\n        svg.setAttribute(\"width\", `${Math.abs(x2 - x1) + padding * 2}`);\n        svg.setAttribute(\"height\", `${Math.abs(y2 - y1) + padding * 2}`);\n\n        const minX = Math.min(x1, x2);\n        const minY = Math.min(y1, y2);\n        svg.setAttribute(\"style\", `position: absolute; top: ${minY - padding}px; left: ${minX - padding}px;`);\n\n        const line = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\n        line.setAttribute(\"x1\", `${Math.abs(x1 - minX) + padding}`);\n        line.setAttribute(\"y1\", `${Math.abs(y1 - minY) + padding}`);\n        line.setAttribute(\"x2\", `${Math.abs(x2 - minX) + padding}`);\n        line.setAttribute(\"y2\", `${Math.abs(y2 - minY) + padding}`);\n        line.setAttribute(\"style\", `stroke: currentColor; stroke-width: ${stroke_width}; stroke-dasharray: 20`);\n\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n\n        let distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance == 0.0) {\n            distance = 0.1;\n        }\n        const normalized_dx = dx / distance;\n        const normalized_dy = dy / distance;\n\n        const size = 10.0;\n        const center_x = (x2 + padding) - normalized_dx * size - minX;\n        const center_y = (y2 + padding) - normalized_dy * size - minY;\n\n        const perp_x = normalized_dy;\n        const perp_y = -normalized_dx;\n\n        const left_x = center_x - perp_x * size;\n        const left_y = center_y - perp_y * size;\n\n        const right_x = center_x + perp_x * size;\n        const right_y = center_y + perp_y * size;\n\n        const path = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n        path.setAttribute(\"d\", `M ${left_x} ${left_y}, L ${x2 - minX + padding} ${y2 - minY + padding}, L ${right_x} ${right_y}`);\n        path.setAttribute(\"style\", `stroke:currentColor; stroke-width: ${stroke_width}; fill: none; stroke-linejoin:round; stroke-linecap:round;`);\n\n        svg.appendChild(line);\n        svg.appendChild(path);\n        document.body.appendChild(svg);\n        return svg;\n    }\n\n    function addSVGCircle(x: number, y: number, radius: number): SVGElement {\n        const svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n        svg.setAttribute(\"width\", `${radius * 2}`);\n        svg.setAttribute(\"height\", `${radius * 2}`);\n        svg.style.position = \"absolute\";\n        svg.style.left = `${x - radius}px`;\n        svg.style.top = `${y - radius}px`;\n        document.body.appendChild(svg);\n\n        const circle = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n        circle.setAttribute(\"cx\", `${radius}`);\n        circle.setAttribute(\"cy\", `${radius}`);\n        circle.setAttribute(\"r\", `${radius}`);\n        svg.appendChild(circle);\n\n        svg.style.filter = \"drop-shadow(2px 3px 2px rgb(0 0 0 / 0.4))\";\n        return svg;\n    };\n\n\n    let imports = {\n        env: {\n            set_color: function (r: number, g: number, b: number, a: number) {\n                context.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;\n            },\n            draw_text: function (x: number, y: number, text_address: number, text_length: number) {\n                let text = tangle.read_string(text_address, text_length);\n                extra_elements.push(addEmoji(text, x, y));\n            },\n            draw_circle: function (x: number, y: number, radius: number) {\n                //extra_elements.push(addSVGCircle(x, y, radius));\n                context.beginPath();\n                context.arc(x, y, radius, 0, 2 * Math.PI);\n                context.fill();\n            },\n            draw_arrow: function (x0: number, y0: number, x1: number, y1: number) {\n                extra_elements.push(addSVGArrow(x0, y0, x1, y1));\n            },\n            begin_path: function () {\n                context.beginPath();\n            },\n            move_to: function (x: number, y: number) {\n                context.moveTo(x, y);\n            },\n            line_to: function (x: number, y: number) {\n                context.lineTo(x, y);\n            },\n            stroke: function () {\n                context.stroke();\n            },\n            fill: function () {\n                context.fill();\n            },\n            translate: function (x: number, y: number) {\n                context.translate(x, y);\n            },\n            rotate: function (radians: number) {\n                context.rotate(radians);\n            },\n            draw_rect: function (x: number, y: number, width: number, height: number) {\n                context.beginPath();\n                context.rect(x, y, width, height);\n                context.fill();\n            },\n            set_transform: function (a: number, b: number, c: number, d: number, e: number, f: number) {\n                context.setTransform(a, b, c, d, e, f);\n            }\n        },\n    };\n\n    let wasm_binary = await fetch(\"rust_project.wasm\").then(response => response.arrayBuffer());\n\n    let result = await Tangle.instanstiate(new Uint8Array(wasm_binary), imports, {\n        fixed_update_interval,\n        on_state_change_callback: (state) => {\n            if (state == TangleState.Connected) {\n                canvas.style.opacity = \"1.0\";\n                if (exports.player_joined) {\n                    exports.player_joined([UserId]);\n                }\n            }\n        },\n    });\n    let tangle = result.tangle;\n    let exports = result.instance.exports;\n\n    document.onpointerdown = async (event) => {\n        let rect = canvas.getBoundingClientRect();\n        if (exports.pointer_down) {\n            exports.pointer_down(UserId, event.clientX - rect.left, event.clientY - rect.top);\n        }\n    };\n\n    document.onpointermove = async (event) => {\n        let rect = canvas.getBoundingClientRect();\n        if (exports.pointer_move) {\n            exports.pointer_move(UserId, event.clientX - rect.left, event.clientY - rect.top);\n        }\n    };\n\n    document.onpointerup = async (event) => {\n        let rect = canvas.getBoundingClientRect();\n\n        if (exports.pointer_up) {\n            console.log(\"EVENT POINTER TYPE: \", event.pointerType);\n            console.log(event.pointerType === \"mouse\");\n            exports.pointer_up(UserId, event.pointerType === \"mouse\", event.clientX - rect.left, event.clientY - rect.top);\n        }\n    };\n\n    document.onkeydown = async (event) => {\n        let rect = canvas.getBoundingClientRect();\n        if (exports.key_down) {\n            exports.key_down(UserId, event.keyCode);\n        }\n        if (event.key == \"h\") {\n            tangle.print_history();\n        }\n    };\n\n    document.onkeyup = async (event) => {\n        let rect = canvas.getBoundingClientRect();\n        if (exports.key_up) {\n            exports.key_up(UserId, event.keyCode);\n        }\n    };\n\n    async function animation() {\n        if (canvas.width != canvas.clientWidth || canvas.height != canvas.clientHeight) {\n            canvas.width = canvas.clientWidth;\n            canvas.height = canvas.clientHeight;\n        }\n\n        extra_elements.forEach((element) => {\n            element.remove();\n        });\n        extra_elements = [];\n\n        context.clearRect(0, 0, context.canvas.width, context.canvas.height);\n\n        exports.draw.callAndRevert();\n\n        window.requestAnimationFrame(animation);\n    }\n    animation();\n}\n\nsetup_demo1();\n"],
  "mappings": "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",
  "names": ["RoomState", "data", "decoder", "event", "i"]
}
